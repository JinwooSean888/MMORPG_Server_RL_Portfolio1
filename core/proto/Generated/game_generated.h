// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAME_GAME_H_
#define FLATBUFFERS_GENERATED_GAME_GAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace game {

struct Vec2;

struct Ping;
struct PingBuilder;

struct Login;
struct LoginBuilder;

struct LoginAck;
struct LoginAckBuilder;

struct EnterField;
struct EnterFieldBuilder;

struct EnterFieldAck;
struct EnterFieldAckBuilder;

struct SkillCmd;
struct SkillCmdBuilder;

struct SkillCmdAck;
struct SkillCmdAckBuilder;

struct Envelope;
struct EnvelopeBuilder;

enum MsgType : uint8_t {
  MsgType_NONE = 0,
  MsgType_Ping = 1,
  MsgType_Login = 2,
  MsgType_EnterField = 3,
  MsgType_LoginAck = 4,
  MsgType_EnterFieldAck = 5,
  MsgType_SkillCmd = 6,
  MsgType_SkillCmdAck = 7,
  MsgType_MIN = MsgType_NONE,
  MsgType_MAX = MsgType_SkillCmdAck
};

inline const MsgType (&EnumValuesMsgType())[8] {
  static const MsgType values[] = {
    MsgType_NONE,
    MsgType_Ping,
    MsgType_Login,
    MsgType_EnterField,
    MsgType_LoginAck,
    MsgType_EnterFieldAck,
    MsgType_SkillCmd,
    MsgType_SkillCmdAck
  };
  return values;
}

inline const char * const *EnumNamesMsgType() {
  static const char * const names[9] = {
    "NONE",
    "Ping",
    "Login",
    "EnterField",
    "LoginAck",
    "EnterFieldAck",
    "SkillCmd",
    "SkillCmdAck",
    nullptr
  };
  return names;
}

inline const char *EnumNameMsgType(MsgType e) {
  if (::flatbuffers::IsOutRange(e, MsgType_NONE, MsgType_SkillCmdAck)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMsgType()[index];
}

enum SkillType : int8_t {
  SkillType_NormalAttack = 0,
  SkillType_MIN = SkillType_NormalAttack,
  SkillType_MAX = SkillType_NormalAttack
};

inline const SkillType (&EnumValuesSkillType())[1] {
  static const SkillType values[] = {
    SkillType_NormalAttack
  };
  return values;
}

inline const char * const *EnumNamesSkillType() {
  static const char * const names[2] = {
    "NormalAttack",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillType(SkillType e) {
  if (::flatbuffers::IsOutRange(e, SkillType_NormalAttack, SkillType_NormalAttack)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillType()[index];
}

enum SkillError : int8_t {
  SkillError_None = 0,
  SkillError_OutOfRange = 1,
  SkillError_Cooldown = 2,
  SkillError_InvalidTarget = 3,
  SkillError_InvalidState = 4,
  SkillError_MIN = SkillError_None,
  SkillError_MAX = SkillError_InvalidState
};

inline const SkillError (&EnumValuesSkillError())[5] {
  static const SkillError values[] = {
    SkillError_None,
    SkillError_OutOfRange,
    SkillError_Cooldown,
    SkillError_InvalidTarget,
    SkillError_InvalidState
  };
  return values;
}

inline const char * const *EnumNamesSkillError() {
  static const char * const names[6] = {
    "None",
    "OutOfRange",
    "Cooldown",
    "InvalidTarget",
    "InvalidState",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillError(SkillError e) {
  if (::flatbuffers::IsOutRange(e, SkillError_None, SkillError_InvalidState)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillError()[index];
}

enum Packet : uint8_t {
  Packet_NONE = 0,
  Packet_Ping = 1,
  Packet_Login = 2,
  Packet_EnterField = 3,
  Packet_LoginAck = 4,
  Packet_EnterFieldAck = 5,
  Packet_SkillCmd = 6,
  Packet_SkillCmdAck = 7,
  Packet_MIN = Packet_NONE,
  Packet_MAX = Packet_SkillCmdAck
};

inline const Packet (&EnumValuesPacket())[8] {
  static const Packet values[] = {
    Packet_NONE,
    Packet_Ping,
    Packet_Login,
    Packet_EnterField,
    Packet_LoginAck,
    Packet_EnterFieldAck,
    Packet_SkillCmd,
    Packet_SkillCmdAck
  };
  return values;
}

inline const char * const *EnumNamesPacket() {
  static const char * const names[9] = {
    "NONE",
    "Ping",
    "Login",
    "EnterField",
    "LoginAck",
    "EnterFieldAck",
    "SkillCmd",
    "SkillCmdAck",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacket(Packet e) {
  if (::flatbuffers::IsOutRange(e, Packet_NONE, Packet_SkillCmdAck)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacket()[index];
}

template<typename T> struct PacketTraits {
  static const Packet enum_value = Packet_NONE;
};

template<> struct PacketTraits<game::Ping> {
  static const Packet enum_value = Packet_Ping;
};

template<> struct PacketTraits<game::Login> {
  static const Packet enum_value = Packet_Login;
};

template<> struct PacketTraits<game::EnterField> {
  static const Packet enum_value = Packet_EnterField;
};

template<> struct PacketTraits<game::LoginAck> {
  static const Packet enum_value = Packet_LoginAck;
};

template<> struct PacketTraits<game::EnterFieldAck> {
  static const Packet enum_value = Packet_EnterFieldAck;
};

template<> struct PacketTraits<game::SkillCmd> {
  static const Packet enum_value = Packet_SkillCmd;
};

template<> struct PacketTraits<game::SkillCmdAck> {
  static const Packet enum_value = Packet_SkillCmdAck;
};

bool VerifyPacket(::flatbuffers::Verifier &verifier, const void *obj, Packet type);
bool VerifyPacketVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENT_TIME_MS = 4
  };
  uint64_t client_time_ms() const {
    return GetField<uint64_t>(VT_CLIENT_TIME_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CLIENT_TIME_MS, 8) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_client_time_ms(uint64_t client_time_ms) {
    fbb_.AddElement<uint64_t>(Ping::VT_CLIENT_TIME_MS, client_time_ms, 0);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t client_time_ms = 0) {
  PingBuilder builder_(_fbb);
  builder_.add_client_time_ms(client_time_ms);
  return builder_.Finish();
}

struct Login FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_TOKEN = 6
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const ::flatbuffers::String *token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           verifier.EndTable();
  }
};

struct LoginBuilder {
  typedef Login Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(Login::VT_USER_ID, user_id);
  }
  void add_token(::flatbuffers::Offset<::flatbuffers::String> token) {
    fbb_.AddOffset(Login::VT_TOKEN, token);
  }
  explicit LoginBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Login>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Login> CreateLogin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> token = 0) {
  LoginBuilder builder_(_fbb);
  builder_.add_token(token);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Login> CreateLoginDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    const char *token = nullptr) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  auto token__ = token ? _fbb.CreateString(token) : 0;
  return game::CreateLogin(
      _fbb,
      user_id__,
      token__);
}

struct LoginAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoginAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OK = 4,
    VT_PLAYER_ID = 6,
    VT_USER_ID = 8,
    VT_DEFAULT_FIELD_ID = 10
  };
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  int32_t default_field_id() const {
    return GetField<int32_t>(VT_DEFAULT_FIELD_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyField<int32_t>(verifier, VT_DEFAULT_FIELD_ID, 4) &&
           verifier.EndTable();
  }
};

struct LoginAckBuilder {
  typedef LoginAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(LoginAck::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(LoginAck::VT_PLAYER_ID, player_id, 0);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(LoginAck::VT_USER_ID, user_id);
  }
  void add_default_field_id(int32_t default_field_id) {
    fbb_.AddElement<int32_t>(LoginAck::VT_DEFAULT_FIELD_ID, default_field_id, 0);
  }
  explicit LoginAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoginAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoginAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoginAck> CreateLoginAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = false,
    uint64_t player_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    int32_t default_field_id = 0) {
  LoginAckBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_default_field_id(default_field_id);
  builder_.add_user_id(user_id);
  builder_.add_ok(ok);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoginAck> CreateLoginAckDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ok = false,
    uint64_t player_id = 0,
    const char *user_id = nullptr,
    int32_t default_field_id = 0) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return game::CreateLoginAck(
      _fbb,
      ok,
      player_id,
      user_id__,
      default_field_id);
}

struct EnterField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_ID = 4
  };
  uint32_t field_id() const {
    return GetField<uint32_t>(VT_FIELD_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_ID, 4) &&
           verifier.EndTable();
  }
};

struct EnterFieldBuilder {
  typedef EnterField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_id(uint32_t field_id) {
    fbb_.AddElement<uint32_t>(EnterField::VT_FIELD_ID, field_id, 0);
  }
  explicit EnterFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterField> CreateEnterField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t field_id = 0) {
  EnterFieldBuilder builder_(_fbb);
  builder_.add_field_id(field_id);
  return builder_.Finish();
}

struct EnterFieldAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnterFieldAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_ID = 4,
    VT_PLAYER_ID = 6
  };
  uint32_t field_id() const {
    return GetField<uint32_t>(VT_FIELD_ID, 0);
  }
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           verifier.EndTable();
  }
};

struct EnterFieldAckBuilder {
  typedef EnterFieldAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_id(uint32_t field_id) {
    fbb_.AddElement<uint32_t>(EnterFieldAck::VT_FIELD_ID, field_id, 0);
  }
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(EnterFieldAck::VT_PLAYER_ID, player_id, 0);
  }
  explicit EnterFieldAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnterFieldAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnterFieldAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnterFieldAck> CreateEnterFieldAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t field_id = 0,
    uint64_t player_id = 0) {
  EnterFieldAckBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_field_id(field_id);
  return builder_.Finish();
}

struct SkillCmd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillCmdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILL = 4,
    VT_TARGETID = 6
  };
  game::SkillType skill() const {
    return static_cast<game::SkillType>(GetField<int8_t>(VT_SKILL, 0));
  }
  uint64_t targetId() const {
    return GetField<uint64_t>(VT_TARGETID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SKILL, 1) &&
           VerifyField<uint64_t>(verifier, VT_TARGETID, 8) &&
           verifier.EndTable();
  }
};

struct SkillCmdBuilder {
  typedef SkillCmd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skill(game::SkillType skill) {
    fbb_.AddElement<int8_t>(SkillCmd::VT_SKILL, static_cast<int8_t>(skill), 0);
  }
  void add_targetId(uint64_t targetId) {
    fbb_.AddElement<uint64_t>(SkillCmd::VT_TARGETID, targetId, 0);
  }
  explicit SkillCmdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkillCmd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkillCmd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkillCmd> CreateSkillCmd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    game::SkillType skill = game::SkillType_NormalAttack,
    uint64_t targetId = 0) {
  SkillCmdBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_skill(skill);
  return builder_.Finish();
}

struct SkillCmdAck FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillCmdAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILL = 4,
    VT_TARGETID = 6,
    VT_OK = 8,
    VT_ERROR = 10
  };
  game::SkillType skill() const {
    return static_cast<game::SkillType>(GetField<int8_t>(VT_SKILL, 0));
  }
  uint64_t targetId() const {
    return GetField<uint64_t>(VT_TARGETID, 0);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 1) != 0;
  }
  game::SkillError error() const {
    return static_cast<game::SkillError>(GetField<int8_t>(VT_ERROR, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SKILL, 1) &&
           VerifyField<uint64_t>(verifier, VT_TARGETID, 8) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           VerifyField<int8_t>(verifier, VT_ERROR, 1) &&
           verifier.EndTable();
  }
};

struct SkillCmdAckBuilder {
  typedef SkillCmdAck Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skill(game::SkillType skill) {
    fbb_.AddElement<int8_t>(SkillCmdAck::VT_SKILL, static_cast<int8_t>(skill), 0);
  }
  void add_targetId(uint64_t targetId) {
    fbb_.AddElement<uint64_t>(SkillCmdAck::VT_TARGETID, targetId, 0);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(SkillCmdAck::VT_OK, static_cast<uint8_t>(ok), 1);
  }
  void add_error(game::SkillError error) {
    fbb_.AddElement<int8_t>(SkillCmdAck::VT_ERROR, static_cast<int8_t>(error), 0);
  }
  explicit SkillCmdAckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkillCmdAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkillCmdAck>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkillCmdAck> CreateSkillCmdAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    game::SkillType skill = game::SkillType_NormalAttack,
    uint64_t targetId = 0,
    bool ok = true,
    game::SkillError error = game::SkillError_None) {
  SkillCmdAckBuilder builder_(_fbb);
  builder_.add_targetId(targetId);
  builder_.add_error(error);
  builder_.add_ok(ok);
  builder_.add_skill(skill);
  return builder_.Finish();
}

struct Envelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PKT_TYPE = 4,
    VT_PKT = 6
  };
  game::Packet pkt_type() const {
    return static_cast<game::Packet>(GetField<uint8_t>(VT_PKT_TYPE, 0));
  }
  const void *pkt() const {
    return GetPointer<const void *>(VT_PKT);
  }
  template<typename T> const T *pkt_as() const;
  const game::Ping *pkt_as_Ping() const {
    return pkt_type() == game::Packet_Ping ? static_cast<const game::Ping *>(pkt()) : nullptr;
  }
  const game::Login *pkt_as_Login() const {
    return pkt_type() == game::Packet_Login ? static_cast<const game::Login *>(pkt()) : nullptr;
  }
  const game::EnterField *pkt_as_EnterField() const {
    return pkt_type() == game::Packet_EnterField ? static_cast<const game::EnterField *>(pkt()) : nullptr;
  }
  const game::LoginAck *pkt_as_LoginAck() const {
    return pkt_type() == game::Packet_LoginAck ? static_cast<const game::LoginAck *>(pkt()) : nullptr;
  }
  const game::EnterFieldAck *pkt_as_EnterFieldAck() const {
    return pkt_type() == game::Packet_EnterFieldAck ? static_cast<const game::EnterFieldAck *>(pkt()) : nullptr;
  }
  const game::SkillCmd *pkt_as_SkillCmd() const {
    return pkt_type() == game::Packet_SkillCmd ? static_cast<const game::SkillCmd *>(pkt()) : nullptr;
  }
  const game::SkillCmdAck *pkt_as_SkillCmdAck() const {
    return pkt_type() == game::Packet_SkillCmdAck ? static_cast<const game::SkillCmdAck *>(pkt()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PKT_TYPE, 1) &&
           VerifyOffset(verifier, VT_PKT) &&
           VerifyPacket(verifier, pkt(), pkt_type()) &&
           verifier.EndTable();
  }
};

template<> inline const game::Ping *Envelope::pkt_as<game::Ping>() const {
  return pkt_as_Ping();
}

template<> inline const game::Login *Envelope::pkt_as<game::Login>() const {
  return pkt_as_Login();
}

template<> inline const game::EnterField *Envelope::pkt_as<game::EnterField>() const {
  return pkt_as_EnterField();
}

template<> inline const game::LoginAck *Envelope::pkt_as<game::LoginAck>() const {
  return pkt_as_LoginAck();
}

template<> inline const game::EnterFieldAck *Envelope::pkt_as<game::EnterFieldAck>() const {
  return pkt_as_EnterFieldAck();
}

template<> inline const game::SkillCmd *Envelope::pkt_as<game::SkillCmd>() const {
  return pkt_as_SkillCmd();
}

template<> inline const game::SkillCmdAck *Envelope::pkt_as<game::SkillCmdAck>() const {
  return pkt_as_SkillCmdAck();
}

struct EnvelopeBuilder {
  typedef Envelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pkt_type(game::Packet pkt_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_PKT_TYPE, static_cast<uint8_t>(pkt_type), 0);
  }
  void add_pkt(::flatbuffers::Offset<void> pkt) {
    fbb_.AddOffset(Envelope::VT_PKT, pkt);
  }
  explicit EnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    game::Packet pkt_type = game::Packet_NONE,
    ::flatbuffers::Offset<void> pkt = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_pkt(pkt);
  builder_.add_pkt_type(pkt_type);
  return builder_.Finish();
}

inline bool VerifyPacket(::flatbuffers::Verifier &verifier, const void *obj, Packet type) {
  switch (type) {
    case Packet_NONE: {
      return true;
    }
    case Packet_Ping: {
      auto ptr = reinterpret_cast<const game::Ping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_Login: {
      auto ptr = reinterpret_cast<const game::Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_EnterField: {
      auto ptr = reinterpret_cast<const game::EnterField *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_LoginAck: {
      auto ptr = reinterpret_cast<const game::LoginAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_EnterFieldAck: {
      auto ptr = reinterpret_cast<const game::EnterFieldAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_SkillCmd: {
      auto ptr = reinterpret_cast<const game::SkillCmd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_SkillCmdAck: {
      auto ptr = reinterpret_cast<const game::SkillCmdAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacket(
        verifier,  values->Get(i), types->GetEnum<Packet>(i))) {
      return false;
    }
  }
  return true;
}

inline const game::Envelope *GetEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<game::Envelope>(buf);
}

inline const game::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<game::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<game::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<game::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<game::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<game::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace game

#endif  // FLATBUFFERS_GENERATED_GAME_GAME_H_
